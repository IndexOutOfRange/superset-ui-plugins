{"version":3,"file":"8.b252512b9102741afe9f.bundle.js","sources":["webpack:////Users/krist_wongsuphasawat/workspace/superset-ui-plugins/node_modules/@vx/stats/dist/vx-stats.es.js"],"sourcesContent":["import React from 'react';\nimport classnames from 'classnames';\nimport { Group } from '@vx/group';\nimport { scaleLinear } from '@vx/scale';\nimport { line, curveCardinal } from 'd3-shape';\n\nfunction callOrValue(maybeFn, data) {\n  if (typeof maybeFn === 'function') {\n    return maybeFn(data);\n  }\n  return maybeFn;\n}\n\nfunction additionalProps(restProps, data) {\n  return Object.keys(restProps).reduce(function (ret, cur) {\n    ret[cur] = callOrValue(restProps[cur], data);\n    return ret;\n  }, {});\n}\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nfunction verticalToHorizontal(_ref) {\n  var _ref2 = slicedToArray(_ref, 4),\n      x1 = _ref2[0],\n      y1 = _ref2[1],\n      x2 = _ref2[2],\n      y2 = _ref2[3];\n\n  return [y1, x1, y2, x2];\n}\n\nfunction BoxPlot(_ref3) {\n  var _ref3$left = _ref3.left,\n      left = _ref3$left === undefined ? 0 : _ref3$left,\n      _ref3$top = _ref3.top,\n      top = _ref3$top === undefined ? 0 : _ref3$top,\n      className = _ref3.className,\n      data = _ref3.data,\n      max = _ref3.max,\n      min = _ref3.min,\n      firstQuartile = _ref3.firstQuartile,\n      thirdQuartile = _ref3.thirdQuartile,\n      median = _ref3.median,\n      boxWidth = _ref3.boxWidth,\n      fill = _ref3.fill,\n      fillOpacity = _ref3.fillOpacity,\n      stroke = _ref3.stroke,\n      strokeWidth = _ref3.strokeWidth,\n      _ref3$rx = _ref3.rx,\n      rx = _ref3$rx === undefined ? 2 : _ref3$rx,\n      _ref3$ry = _ref3.ry,\n      ry = _ref3$ry === undefined ? 2 : _ref3$ry,\n      valueScale = _ref3.valueScale,\n      outliers = _ref3.outliers,\n      horizontal = _ref3.horizontal,\n      _ref3$medianProps = _ref3.medianProps,\n      medianProps = _ref3$medianProps === undefined ? {} : _ref3$medianProps,\n      _ref3$maxProps = _ref3.maxProps,\n      maxProps = _ref3$maxProps === undefined ? {} : _ref3$maxProps,\n      _ref3$minProps = _ref3.minProps,\n      minProps = _ref3$minProps === undefined ? {} : _ref3$minProps,\n      _ref3$boxProps = _ref3.boxProps,\n      boxProps = _ref3$boxProps === undefined ? {} : _ref3$boxProps,\n      _ref3$outlierProps = _ref3.outlierProps,\n      outlierProps = _ref3$outlierProps === undefined ? {} : _ref3$outlierProps,\n      _ref3$container = _ref3.container,\n      container = _ref3$container === undefined ? false : _ref3$container,\n      _ref3$containerProps = _ref3.containerProps,\n      containerProps = _ref3$containerProps === undefined ? {} : _ref3$containerProps,\n      restProps = objectWithoutProperties(_ref3, ['left', 'top', 'className', 'data', 'max', 'min', 'firstQuartile', 'thirdQuartile', 'median', 'boxWidth', 'fill', 'fillOpacity', 'stroke', 'strokeWidth', 'rx', 'ry', 'valueScale', 'outliers', 'horizontal', 'medianProps', 'maxProps', 'minProps', 'boxProps', 'outlierProps', 'container', 'containerProps']);\n\n  var offset = horizontal ? top : left;\n  var center = offset + boxWidth / 2;\n\n  var maxLinePos = Array(4).fill(0);\n  var maxToBoxLinePos = Array(4).fill(0);\n  var boxPos = Array(4).fill(0);\n  var medianLinePos = Array(4).fill(0);\n  var minToBoxLinePos = Array(4).fill(0);\n  var minLinePos = Array(4).fill(0);\n  var containerPos = Array(4).fill(0);\n\n  // all of these are [x0, y0, x1, y1]\n  maxLinePos[0] = center - boxWidth / 4;\n  maxLinePos[1] = valueScale(max);\n  maxLinePos[2] = center + boxWidth / 4;\n  maxLinePos[3] = valueScale(max);\n\n  maxToBoxLinePos[0] = center;\n  maxToBoxLinePos[1] = valueScale(max);\n  maxToBoxLinePos[2] = center;\n  maxToBoxLinePos[3] = valueScale(thirdQuartile);\n\n  boxPos[0] = offset;\n  boxPos[1] = valueScale(thirdQuartile);\n  boxPos[2] = boxWidth;\n  boxPos[3] = Math.abs(valueScale(thirdQuartile) - valueScale(firstQuartile));\n\n  medianLinePos[0] = offset;\n  medianLinePos[1] = valueScale(median);\n  medianLinePos[2] = offset + boxWidth;\n  medianLinePos[3] = valueScale(median);\n\n  minToBoxLinePos[0] = center;\n  minToBoxLinePos[1] = valueScale(firstQuartile);\n  minToBoxLinePos[2] = center;\n  minToBoxLinePos[3] = valueScale(min);\n\n  minLinePos[0] = center - boxWidth / 4;\n  minLinePos[1] = valueScale(min);\n  minLinePos[2] = center + boxWidth / 4;\n  minLinePos[3] = valueScale(min);\n\n  var valueRange = valueScale.range();\n  containerPos[0] = boxPos[0];\n  containerPos[1] = Math.min.apply(Math, toConsumableArray(valueRange));\n  containerPos[2] = boxPos[2];\n  containerPos[3] = Math.abs(valueRange[0] - valueRange[1]);\n\n  if (horizontal) {\n    maxLinePos = verticalToHorizontal(maxLinePos);\n    maxToBoxLinePos = verticalToHorizontal(maxToBoxLinePos);\n    boxPos = verticalToHorizontal(boxPos);\n    boxPos[0] = valueScale(firstQuartile);\n    medianLinePos = verticalToHorizontal(medianLinePos);\n    minToBoxLinePos = verticalToHorizontal(minToBoxLinePos);\n    minLinePos = verticalToHorizontal(minLinePos);\n    containerPos = verticalToHorizontal(containerPos);\n    containerPos[0] = Math.min.apply(Math, toConsumableArray(valueRange));\n  }\n  return React.createElement(\n    Group,\n    { className: classnames('vx-boxplot', className) },\n    outliers.map(function (d, i) {\n      var cx = horizontal ? valueScale(d) : center;\n      var cy = horizontal ? center : valueScale(d);\n      return React.createElement('circle', _extends({\n        key: i,\n        className: 'vx-boxplot-outlier',\n        cx: cx,\n        cy: cy,\n        stroke: stroke,\n        strokeWidth: 1,\n        fill: fill,\n        fillOpacity: fillOpacity,\n        r: '4'\n      }, additionalProps(outlierProps, {\n        data: d,\n        cx: cx,\n        cy: cy\n      })));\n    }),\n    React.createElement('line', _extends({\n      className: 'vx-boxplot-max',\n      x1: maxLinePos[0],\n      y1: maxLinePos[1],\n      x2: maxLinePos[2],\n      y2: maxLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }, additionalProps(maxProps, {\n      data: data,\n      max: max,\n      x1: maxLinePos[0],\n      x2: maxLinePos[2],\n      y1: maxLinePos[1],\n      y2: maxLinePos[3]\n    }))),\n    React.createElement('line', {\n      x1: maxToBoxLinePos[0],\n      y1: maxToBoxLinePos[1],\n      x2: maxToBoxLinePos[2],\n      y2: maxToBoxLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }),\n    React.createElement('rect', _extends({\n      className: 'vx-boxplot-box',\n      x: boxPos[0],\n      y: boxPos[1],\n      width: boxPos[2],\n      height: boxPos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      fill: fill,\n      fillOpacity: fillOpacity,\n      rx: rx,\n      ry: ry\n    }, additionalProps(boxProps, {\n      data: data,\n      height: boxPos[3],\n      median: median,\n      firstQuartile: firstQuartile,\n      thirdQuartile: thirdQuartile,\n      min: min,\n      max: max,\n      x1: boxPos[0],\n      x2: boxPos[0] + boxPos[2],\n      y1: boxPos[1],\n      y2: boxPos[1] + boxPos[3]\n    }))),\n    React.createElement('line', _extends({\n      className: 'vx-boxplot-median',\n      x1: medianLinePos[0],\n      y1: medianLinePos[1],\n      x2: medianLinePos[2],\n      y2: medianLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }, additionalProps(medianProps, {\n      data: data,\n      median: median,\n      x1: medianLinePos[0],\n      x2: medianLinePos[2],\n      y1: medianLinePos[1],\n      y2: medianLinePos[3]\n    }))),\n    React.createElement('line', {\n      x1: minToBoxLinePos[0],\n      y1: minToBoxLinePos[1],\n      x2: minToBoxLinePos[2],\n      y2: minToBoxLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }),\n    React.createElement('line', _extends({\n      className: 'vx-boxplot-min',\n      x1: minLinePos[0],\n      y1: minLinePos[1],\n      x2: minLinePos[2],\n      y2: minLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }, additionalProps(minProps, {\n      data: data,\n      min: min,\n      x1: minLinePos[0],\n      x2: minLinePos[2],\n      y1: minLinePos[1],\n      y2: minLinePos[3]\n    }))),\n    container && React.createElement('rect', _extends({\n      x: containerPos[0],\n      y: containerPos[1],\n      width: containerPos[2],\n      height: containerPos[3],\n      fillOpacity: '0'\n    }, additionalProps(containerProps, {\n      data: data,\n      x1: containerPos[0],\n      x2: containerPos[0] + containerPos[2],\n      y1: containerPos[1],\n      y2: containerPos[1] + containerPos[3],\n      median: median,\n      max: max,\n      min: min,\n      thirdQuartile: thirdQuartile,\n      firstQuartile: firstQuartile\n    })))\n  );\n}\n\nfunction ViolinPlot(_ref) {\n  var _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      className = _ref.className,\n      binData = _ref.binData,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'rgba(0,0,0,0.3)' : _ref$fill,\n      opacity = _ref.opacity,\n      strokeWidth = _ref.strokeWidth,\n      width = _ref.width,\n      valueScale = _ref.valueScale,\n      strokeDasharray = _ref.strokeDasharray,\n      horizontal = _ref.horizontal,\n      restProps = objectWithoutProperties(_ref, ['left', 'top', 'className', 'binData', 'stroke', 'fill', 'opacity', 'strokeWidth', 'width', 'valueScale', 'strokeDasharray', 'horizontal']);\n\n  var center = (horizontal ? top : left) + width / 2;\n  var binCounts = binData.map(function (bin) {\n    return bin.count;\n  });\n  var widthScale = scaleLinear({\n    rangeRound: [0, width / 2],\n    domain: [0, Math.max.apply(Math, toConsumableArray(binCounts))]\n  });\n\n  var path = '';\n  if (horizontal) {\n    var topCurve = line().x(function (d) {\n      return valueScale(d.value);\n    }).y(function (d) {\n      return center - widthScale(d.count);\n    }).curve(curveCardinal);\n\n    var bottomCurve = line().x(function (d) {\n      return valueScale(d.value);\n    }).y(function (d) {\n      return center + widthScale(d.count);\n    }).curve(curveCardinal);\n\n    var topCurvePath = topCurve(binData);\n    var bottomCurvePath = bottomCurve([].concat(toConsumableArray(binData)).reverse());\n    path = topCurvePath + ' ' + bottomCurvePath.replace('M', 'L') + ' Z';\n  } else {\n    var rightCurve = line().x(function (d) {\n      return center + widthScale(d.count);\n    }).y(function (d) {\n      return valueScale(d.value);\n    }).curve(curveCardinal);\n\n    var leftCurve = line().x(function (d) {\n      return center - widthScale(d.count);\n    }).y(function (d) {\n      return valueScale(d.value);\n    }).curve(curveCardinal);\n\n    var rightCurvePath = rightCurve(binData);\n    var leftCurvePath = leftCurve([].concat(toConsumableArray(binData)).reverse());\n    path = rightCurvePath + ' ' + leftCurvePath.replace('M', 'L') + ' Z';\n  }\n  return React.createElement(\n    Group,\n    { className: classnames('vx-violin', className) },\n    React.createElement('path', _extends({\n      d: path,\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      fill: fill,\n      fillOpacity: opacity\n    }, additionalProps(restProps, binData)))\n  );\n}\n\nfunction computeStats (numericalArray) {\n  var points = [].concat(toConsumableArray(numericalArray)).sort(function (a, b) {\n    return a - b;\n  });\n  var sampleSize = points.length;\n  var firstQuartile = points[Math.round(sampleSize / 4)];\n  var thirdQuartile = points[Math.round(3 * sampleSize / 4)];\n  var IQR = thirdQuartile - firstQuartile;\n\n  var min = firstQuartile - 1.5 * IQR;\n  var max = thirdQuartile + 1.5 * IQR;\n\n  var outliers = points.filter(function (p) {\n    return p < min || p > max;\n  });\n  var binWidth = 2 * IQR * Math.pow(sampleSize - outliers.length, -1 / 3);\n  var binNum = Math.round((max - min) / binWidth);\n  var actualBinWidth = (max - min) / binNum;\n\n  var bins = Array(binNum + 2).fill(0);\n  var values = Array(binNum + 2).fill(min);\n\n  for (var i = 1; i <= binNum; i += 1) {\n    values[i] += actualBinWidth * (i - 0.5);\n  }\n\n  values[values.length - 1] = max;\n\n  points.filter(function (p) {\n    return p >= min && p <= max;\n  }).forEach(function (p) {\n    bins[Math.floor((p - min) / actualBinWidth) + 1] += 1;\n  });\n\n  var binData = values.map(function (v, i) {\n    return {\n      value: v,\n      count: bins[i]\n    };\n  });\n\n  var boxPlot = {\n    min: min,\n    firstQuartile: firstQuartile,\n    median: points[Math.round(sampleSize / 2)],\n    thirdQuartile: thirdQuartile,\n    max: max,\n    outliers: outliers\n  };\n\n  return {\n    boxPlot: boxPlot,\n    binData: binData\n  };\n}\n\nexport { BoxPlot, ViolinPlot, computeStats };\n"],"mappings":"AAaA","sourceRoot":""}